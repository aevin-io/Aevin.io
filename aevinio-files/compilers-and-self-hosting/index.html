<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Compilers and Self-hosting - aevin.io</title><meta name="description" content="Compilers and Self-hosting, aevin.io, aevin"><meta name="generator" content="Publii Open-Source CMS for Static Site"><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=G-9X8HEPJ6F8"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', 'G-9X8HEPJ6F8' );</script><link rel="canonical" href="./../compilers-and-self-hosting/"><link rel="preload" href="./../assets/dynamic/fonts/spartan/spartan.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="./../assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="./../assets/css/style.css?v=b7555137b16fbd19daff75701499684e"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./../compilers-and-self-hosting/"},"headline":"Compilers and Self-hosting","datePublished":"2024-07-01T16:41","dateModified":"2024-07-01T17:02","image":{"@type":"ImageObject","url":"./../media/website/logosvg.svg","height":322,"width":1073},"description":"Compilers and Self-hosting, aevin.io, aevin","author":{"@type":"Person","name":"aevin","url":"./../authors/aevin/"},"publisher":{"@type":"Organization","name":"aevin","logo":{"@type":"ImageObject","url":"./../media/website/logosvg.svg","height":322,"width":1073}}}</script><script defer="defer" data-domain="aevin.io" src="https://plausible.io/js/script.file-downloads.hash.outbound-links.js"></script><script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script></head><body><div class="container"><header class="header"><a href="./../" class="logo"><img src="./../media/website/logosvg.svg" alt="aevin.io" width="1073" height="322"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu">Menu</button><ul class="navbar__menu"><li class="has-submenu"><a href="./../tags/visual/" target="_self" aria-haspopup="true">VISUAL</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../tags/generative/" title="dd" target="_self">Generative</a></li><li><a href="./../tags/digital/" target="_self">Digital Art</a></li><li><a href="./../tags/motion/" target="_self">Motion Graphics</a></li></ul></li><li class="has-submenu"><a href="./../tags/audio/" target="_self" aria-haspopup="true">AUDIO</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../tags/release/" target="_self">Releases</a></li><li><a href="./../tags/lives/" target="_self">Performance</a></li><li><a href="./../studio-2/" target="_self">Studio</a></li><li><a href="./../pending/" target="_self">Pending</a></li></ul></li><li class="monospaced has-submenu"><a href="./../tags/memex/" target="_self" aria-haspopup="true">MEMEX</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../tags/notes/" target="_self">Notebook</a></li><li><a href="./../tags/research/" target="_self">Research</a></li><li class="monospaced"><a href="./../journal/" target="_self">Journal</a></li><li><a href="./../tags/bookmarks/" target="_self">Bookmarks</a></li><li><a href="./../tags/retrospective/" target="_self">Retrospective</a></li><li><a href="./../tags/inventory/" target="_self">Inventory</a></li></ul></li><li class="has-submenu"><a href="./../tags/about/" target="_self" aria-haspopup="true">ABOUT</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../this-site-about/" target="_self">This Site</a></li><li><a href="./../aboutself/" target="_self">Teo Aevin</a></li><li><a href="./../connect/" target="_self">Connect</a></li></ul></li></ul></nav></header><main class="main"><article class="post"><header class="post__inner post__header"><h1 class="post__title">Compilers and Self-hosting</h1></header><div class="post__inner"><div class="post__entry"><p>It can indeed seem paradoxical at first glance, but the process of creating an assembler, or indeed any software development tool, follows a logical sequence that builds on itself. Here's a breakdown of how this works:</p><h3>Historical Context: Bootstrap Compilers and Assemblers</h3><ol><li><p><strong>Manual Encoding</strong>:</p><ul><li>In the early days of computing, the first programs, including assemblers and compilers, were written in machine code by hand. Programmers would write the binary instructions directly, or they would use switches on the front panel of the computer to enter machine code instructions.</li></ul></li><li><p><strong>First Assembler</strong>:</p><ul><li>Once the first assembler was created using machine code, it simplified the process of writing further software. This assembler could then translate assembly language into machine code, which made programming easier.</li></ul></li><li><p><strong>Higher-Level Languages</strong>:</p><ul><li>With an assembler available, programmers could write more sophisticated programs, including those that would be used to develop higher-level languages like C.</li><li>The first compilers for these higher-level languages were often written in assembly language. Once a compiler existed, it could compile higher-level language code into machine code.</li></ul></li></ol><h3>Modern Development: Bootstrapping</h3><ol><li><p><strong>Writing Assemblers in Higher-Level Languages</strong>:</p><ul><li>Modern assemblers are often written in higher-level languages like C for ease of development, maintainability, and portability.</li><li>The C compiler itself is a complex piece of software but follows the same principles.</li></ul></li><li><p><strong>Bootstrapping Process</strong>:</p><ul><li><strong>Initial Compiler/Assembler</strong>: The initial compiler or assembler for a new language can be written in assembly or an already established higher-level language.</li><li><strong>Cross-Compilation</strong>: Often, a new compiler or assembler is developed on an existing system using an existing compiler. This is called cross-compilation, where the compiler runs on one system but generates code for another system.</li></ul></li><li><p><strong>Self-Hosting</strong>:</p><ul><li><em>Once a compiler or assembler for a higher-level language like C is written, it can be compiled using an existing compiler.</em></li><li><em>After it’s compiled and functional, subsequent versions of the compiler can be written in its own language. For example, a C compiler can be written in C. This is known as self-hosting.</em></li></ul></li></ol><p>more on Self-hosting later... </p><h3>Example: GCC Compiler</h3><ul><li><strong>Initial Development</strong>: The GNU Compiler Collection (GCC) was initially written in C.</li><li><strong>Bootstrapping</strong>: The first version of GCC was compiled using an existing C compiler. Once GCC was working, subsequent versions of GCC could be compiled using GCC itself.</li></ul><h3>Conceptual Process</h3><ol><li><strong>Manual Bootstrapping</strong>: The very first tools were written manually in machine code.</li><li><strong>First Assemblers/Compilers</strong>: These tools enabled the creation of slightly more complex tools.</li><li><strong>Iterative Improvement</strong>: With each step, new tools enabled the creation of even more sophisticated software.</li><li><strong>Self-Hosting Compilers</strong>: Eventually, languages could be used to write their own compilers, creating a virtuous cycle of improvement.</li></ol><p> </p><div class="flex flex-grow flex-col max-w-full"><div class="min-h-[20px] text-message flex flex-col items-start whitespace-pre-wrap break-words [.text-message+&amp;]:mt-5 juice:w-full juice:items-end overflow-x-auto gap-2" dir="auto" data-message-author-role="assistant" data-message-id="9a952c4c-1e25-45f3-9f61-3c57fdd33727"><div class="flex w-full flex-col gap-1 juice:empty:hidden juice:first:pt-[3px]"><h3>Self-Hosting in Simple Terms</h3><ol><li><p><strong>Initial Compiler Development</strong>:</p><ul><li>When creating a new programming language like Amber, the first step is to write a compiler (or interpreter) for that language.</li><li>This initial compiler is typically written in an existing, well-established language like C, C++, or even another high-level language such as Python or Java.</li><li>Let's say we choose to write the first version of the Amber compiler in C.</li></ul></li><li><p><strong>Bootstrap Compilation</strong>:</p><ul><li>Once the initial version of the Amber compiler is written in C, you compile it using a C compiler that already exists on your computer. This produces an executable or binary file that is the Amber compiler itself.</li></ul></li><li><p><strong>Using the Amber Compiler</strong>:</p><ul><li>Now that you have the Amber compiler executable, you can use it to compile programs written in Amber language into executable programs or other forms of output.</li><li>This compiler is capable of understanding and processing Amber language syntax and semantics because it was specifically designed to do so.</li></ul></li><li><p><strong>Self-Hosting Aspect</strong>:</p><ul><li><strong>Continued Development</strong>: As you continue to develop the Amber language, you might want to introduce new features, improve performance, fix bugs, etc.</li><li><strong>Writing in Amber</strong>: For future versions of the Amber compiler, you can indeed write the new compiler in Amber itself. This means using the existing Amber compiler to compile the newer version of the Amber compiler.</li><li><strong>Advantages</strong>: Writing the compiler in Amber allows you to fully leverage the capabilities and features of the Amber language. It also ensures that the compiler remains consistent with the language's evolving syntax and semantics.</li></ul></li><li><p><strong>Iterative Improvement</strong>:</p><ul><li>Each new version of the Amber compiler can be written in Amber, compiled by the previous version of the Amber compiler. This iterative process is what we refer to as self-hosting.</li></ul></li></ol><h3>Why Self-Hosting?</h3><ul><li><strong>Language Consistency</strong>: Ensures that the compiler and the language it compiles are closely aligned and can evolve together.</li><li><strong>Leveraging Language Features</strong>: Allows you to use Amber's features to implement more advanced optimizations and features in the compiler itself.</li><li><strong>Community Contribution</strong>: Makes it easier for others in the Amber community to contribute to the development of the compiler since they can work directly in Amber.</li></ul><h3>Practical Example</h3><ul><li>Initially, you might write Amber compiler v1.0 in C.</li><li>Using this v1.0 compiler, you compile programs written in Amber.</li><li>When developing Amber v2.0, you write the compiler in Amber and compile it using v1.0.</li><li>This ensures that Amber v2.0 compiler understands and can process the new features introduced in Amber v2.0.</li></ul><p>In summary, self-hosting means writing a compiler for a programming language in the same language it is intended to compile. This approach allows for a more integrated and consistent development process as the language evolves over time. It’s a practical way to ensure that the compiler stays up-to-date with the latest language features and improvements.</p><h4>Assembly</h4><p>Assembler code, often referred to as assembly language, is written in a specific assembly language that corresponds to a particular CPU architecture. Each type of CPU architecture (e.g., x86, ARM, MIPS) has its own unique assembly language syntax and instruction set. Here’s a closer look at what this entails:</p><p><strong>Assembly Language</strong></p><br>Assembly language is a low-level programming language that uses mnemonic codes and symbols to represent machine-level instructions.<br>It is specific to a given CPU architecture, meaning that the assembly language for an x86 processor differs from the assembly language for an ARM processor.</div><div> </div><div class="flex w-full flex-col gap-1 juice:empty:hidden juice:first:pt-[3px]"><strong>Assembler</strong></div><div class="flex w-full flex-col gap-1 juice:empty:hidden juice:first:pt-[3px]"><br>The assembler is the tool that translates the written assembly language code into machine code (binary code) that the CPU can execute.<br>Each assembler is designed to handle the syntax and instruction set of a specific assembly language.<br>Unlike higher-level languages, <strong>assembly language does not have an intermediate step like compilation or interpretation.</strong> There's no separate executable file generated from assembly code; the output of the assembler is the machine code itself.<br><br></div></div></div></div><footer class="post__footer"><div class="post__tag-share"><div class="post__tag"><h3 class="post__tag__title">Posted in</h3><ul class="post__tag__list"><li><a href="./../tags/memex/">Memex</a></li><li><a href="./../tags/notes/">Notebook</a></li></ul></div></div></footer></div></article></main><footer class="footer"><div class="footer__left"><div class="footer__copy">aevin.io 2024</div></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="./../assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = { mobileMenuMode: 'sidebar', animationSpeed: 300, submenuWidth: 'auto', doubleClickTime: 500, mobileMenuExpandableSubmenus: true, relatedContainerForOverlayMenuSelector: '.navbar', };</script><script defer="defer" src="./../assets/js/scripts.min.js?v=f29202381954a095b7f91124e2040dca"></script><script>function publiiDetectLoadedImages () {
         var images = document.querySelectorAll('img[loading]:not(.is-loaded)');
         for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
               images[i].classList.add('is-loaded');
               images[i].parentNode.classList.remove('is-img-loading');
            } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
                  this.parentNode.classList.remove('is-img-loading');
               }, false);
            }
         }
      }
      publiiDetectLoadedImages();</script></body></html>