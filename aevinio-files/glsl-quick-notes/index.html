<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>GLSL Quick notes - aevin.io</title><meta name="description" content="GLSL Quick notes, aevin.io, aevin"><meta name="generator" content="Publii Open-Source CMS for Static Site"><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=G-9X8HEPJ6F8"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', 'G-9X8HEPJ6F8' );</script><link rel="canonical" href="./../glsl-quick-notes/"><link rel="preload" href="./../assets/dynamic/fonts/spartan/spartan.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="./../assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="./../assets/css/style.css?v=b7555137b16fbd19daff75701499684e"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./../glsl-quick-notes/"},"headline":"GLSL Quick notes","datePublished":"2024-06-22T16:55","dateModified":"2024-07-01T17:05","image":{"@type":"ImageObject","url":"./../media/website/logosvg.svg","height":322,"width":1073},"description":"GLSL Quick notes, aevin.io, aevin","author":{"@type":"Person","name":"aevin","url":"./../authors/aevin/"},"publisher":{"@type":"Organization","name":"aevin","logo":{"@type":"ImageObject","url":"./../media/website/logosvg.svg","height":322,"width":1073}}}</script><script defer="defer" data-domain="aevin.io" src="https://plausible.io/js/script.file-downloads.hash.outbound-links.js"></script><script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script></head><body><div class="container"><header class="header"><a href="./../" class="logo"><img src="./../media/website/logosvg.svg" alt="aevin.io" width="1073" height="322"></a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu">Menu</button><ul class="navbar__menu"><li class="has-submenu"><a href="./../tags/visual/" target="_self" aria-haspopup="true">VISUAL</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../tags/generative/" title="dd" target="_self">Generative</a></li><li><a href="./../tags/digital/" target="_self">Digital Art</a></li><li><a href="./../tags/motion/" target="_self">Motion Graphics</a></li></ul></li><li class="has-submenu"><a href="./../tags/audio/" target="_self" aria-haspopup="true">AUDIO</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../tags/release/" target="_self">Releases</a></li><li><a href="./../tags/lives/" target="_self">Performance</a></li><li><a href="./../studio-2/" target="_self">Studio</a></li><li><a href="./../pending/" target="_self">Pending</a></li></ul></li><li class="monospaced has-submenu"><a href="./../tags/memex/" target="_self" aria-haspopup="true">MEMEX</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../tags/notes/" target="_self">Notebook</a></li><li><a href="./../tags/research/" target="_self">Research</a></li><li class="monospaced"><a href="./../journal/" target="_self">Journal</a></li><li><a href="./../tags/bookmarks/" target="_self">Bookmarks</a></li><li><a href="./../tags/retrospective/" target="_self">Retrospective</a></li><li><a href="./../tags/inventory/" target="_self">Inventory</a></li></ul></li><li class="has-submenu"><a href="./../tags/about/" target="_self" aria-haspopup="true">ABOUT</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="./../this-site-about/" target="_self">This Site</a></li><li><a href="./../aboutself/" target="_self">Teo Aevin</a></li><li><a href="./../connect/" target="_self">Connect</a></li></ul></li></ul></nav></header><main class="main"><article class="post"><header class="post__inner post__header"><h1 class="post__title">GLSL Quick notes</h1></header><div class="post__inner"><div class="post__entry"><p> </p><ol><li><p><strong>Source</strong>:</p><ul><li><code>gl_FragCoord</code> is provided by GLSL and automatically populated with the current fragment’s coordinates.</li><li><code>u_resolution</code> is provided by the user, typically set in the application code.</li></ul></li><li><p><strong>Usage</strong>:</p><ul><li><code>gl_FragCoord</code> is used to obtain the position of the current fragment.</li><li><code>u_resolution</code> is used to get the dimensions of the rendering target, often for normalizing coordinates or other resolution-dependent calculations.</li></ul></li><li><p><strong>Accessibility</strong>:</p><ul><li><code>gl_FragCoord</code> is always available in fragment shaders without any additional setup.</li><li><code>u_resolution</code> requires defining and passing from the application.</li></ul></li></ol><p>When you divide <code>gl_FragCoord.xy</code> by <code>u_resolution</code>, you <strong><span style="text-decoration: underline;">normalize</span> the fragment coordinates</strong> to a range of [0, 1], where (0, 0) represents the bottom-left corner and (1, 1) represents the top-right corner of the screen or rendering target. This allows you to work with coordinates that are <span style="text-decoration: underline;">independent of the actual screen resolution.</span></p><p>The value of <code>gl_FragCoord.xy</code> is determined <strong>by the position of the fragment within the framebuffer during rendering</strong>. <code>gl_FragCoord.xy</code> varies for each fragment within a rendered frame. Each fragment corresponds to a pixel, and <code>gl_FragCoord.xy</code> provides the window-relative coordinates for that fragment.</p><h3>How <code>gl_FragCoord.xy</code> Works</h3><ul><li><strong>Per-Fragment Basis</strong>: The value of <code>gl_FragCoord.xy</code> is different for each fragment (or pixel) being processed in a single frame. It provides the exact position of the fragment within the framebuffer.</li><li><strong>Coordinates</strong>:<ul><li><code>gl_FragCoord.x</code> is the horizontal coordinate.</li><li><code>gl_FragCoord.y</code> is the vertical coordinate.</li></ul></li><li><strong>Origin and Range</strong>:<ul><li>The origin (0, 0) is at the bottom-left corner of the framebuffer.</li><li>The maximum values are the width and height of the framebuffer.</li></ul></li></ul><p> </p><p>A <strong>fragment</strong> is an intermediate result produced by the rasterization stage of the graphics pipeline. It contains all the information needed to potentially contribute to a final pixel's color, depth, and other attributes.<br>A <strong>pixel</strong> (short for "picture element") refers to the final discrete element of an image as it appears on the screen after all processing is complete.</p><p> </p><p> </p><p class="align-left"><strong>Uniforms Changing Between Frames</strong>: Uniforms can indeed change from one frame to another in a rendering application. This allows for dynamic updates such as moving objects, changing lighting conditions, or adjusting camera perspectives.</p><p class="align-left"><strong>Uniforms Consistency Within a Frame</strong>: Within a single frame render, once set, the values of uniforms remain constant throughout all draw calls issued during that frame. This ensures that all objects rendered within that frame use the same set of parameters (like transformation matrices, light positions) unless explicitly update</p><p><strong>constant variables</strong> in GLSL remain unchanged throughout the entire execution of a shader program, spanning multiple frames if necessary. </p><p> </p><p>we dont have to manual iterate each pixel (for example using a for loop and we could need in a lets say p5js context) to find out each value. instead gl_Fragcoord gives a different coordinate for each fragment (pixel) during rendering and gl_Fragcolor sets the color value for each pixel:</p><p> </p><ol><li><p><strong>Vertex Shader (<code>main()</code> function)</strong>:</p><ul><li>The <code>main()</code> function in a vertex shader<strong> is executed once per vertex. </strong>Its primary responsibility is to process individual vertices, transforming them from object space to clip space (where they can be rasterized into fragments).</li><li>This function does not execute per fragment; rather, it prepares vertices for subsequent stages of the rendering pipeline.</li></ul></li><li><p><strong>Fragment Shader (<code>main()</code> function)</strong>:</p><ul><li>The <code>main()</code> function in a fragment shader <strong>is executed once per fragment.</strong> Fragments are generated during the rasterization stage, where each fragment represents a pixel (or part of a pixel) on the screen.</li><li>Within the fragment shader, calculations such as color determination, texture mapping, lighting computations, and other effects are performed for each fragment.</li></ul></li></ol><p> </p><p><code>draw()</code> in p5.js operates at the frame level, updating the entire canvas.<br><code>main()</code> in GLSL operates at the pixel (fragment) level, processing individual pixels based on shader logic.</p><p> </p><blockquote><p>The use of U and V coordinates instead of X and Y coordinates in the context of texture mapping comes from historical conventions in computer graphics. The terms U and V were likely chosen to avoid confusion with the X and Y coordinates used in 2D screen space.</p><p>When you're working in a 3D environment, you already have X, Y, and Z coordinates representing the spatial dimensions. Introducing a different set of letters (U and V) for texture coordinates helps to distinguish between the spatial coordinates of the 3D geometry and the coordinates used for mapping textures onto that geometry.</p><p>In mathematical terms, U and V are simply variables representing the axes of the texture space. It's a convention that has been widely adopted in computer graphics, and it helps maintain clarity when discussing both spatial and texture coordinates within the same context.</p></blockquote><p> </p><p> </p><p>emmet shortcut increment &lt;3 </p><p>https://dev.to/robole/vs-code-quickly-increment-and-decrement-numeric-values-with-keyboard-shortcuts-2nl</p></div><footer class="post__footer"><div class="post__tag-share"><div class="post__tag"><h3 class="post__tag__title">Posted in</h3><ul class="post__tag__list"><li><a href="./../tags/memex/">Memex</a></li><li><a href="./../tags/notes/">Notebook</a></li></ul></div></div></footer></div></article></main><footer class="footer"><div class="footer__left"><div class="footer__copy">aevin.io 2024</div></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="./../assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = { mobileMenuMode: 'sidebar', animationSpeed: 300, submenuWidth: 'auto', doubleClickTime: 500, mobileMenuExpandableSubmenus: true, relatedContainerForOverlayMenuSelector: '.navbar', };</script><script defer="defer" src="./../assets/js/scripts.min.js?v=f29202381954a095b7f91124e2040dca"></script><script>function publiiDetectLoadedImages () {
         var images = document.querySelectorAll('img[loading]:not(.is-loaded)');
         for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
               images[i].classList.add('is-loaded');
               images[i].parentNode.classList.remove('is-img-loading');
            } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
                  this.parentNode.classList.remove('is-img-loading');
               }, false);
            }
         }
      }
      publiiDetectLoadedImages();</script></body></html>